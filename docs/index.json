[
  {
    "description": "Deregisters a key command listener, given matching `commands` and\n `callback` parameters.",
    "tags": [
      {
        "title": "public",
        "description": null,
        "lineNumber": 4,
        "type": null
      },
      {
        "title": "example",
        "description": "Keypress.deregister('shift d') // Deregisters all triggers for `shift d`",
        "lineNumber": 5
      },
      {
        "title": "example",
        "description": "Keypress.deregister('esc', hide) // Deregisters triggers matching callback function `hide` and key `esc`",
        "lineNumber": 6
      },
      {
        "title": "param",
        "description": "Human readable key or key combination to listen for, in the form of \"a\"\n   or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ]
            }
          ]
        },
        "name": "commands"
      },
      {
        "title": "param",
        "description": "Callback function to execute when key is pressed. This is if you want\n   to only remove key handlers that match the same callback. If you do not\n   provide a callback, all handlers that match `commands` are removed.",
        "lineNumber": 11,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "function"
          }
        },
        "name": "callback"
      },
      {
        "title": "todo",
        "description": "Because of how function equality works, not all functions passed\n   in this way result in a true test of equality.",
        "lineNumber": 15
      },
      {
        "title": "name",
        "name": "deregister"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 239,
        "column": 2
      },
      "end": {
        "line": 256,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 257,
          "column": 2
        },
        "end": {
          "line": 290,
          "column": 3
        }
      },
      "file": "/Users/lou/Repositories/codeforamerica/streetmix/assets/js/app/keypress.js",
      "code": "{\n  'use strict'\n\n  /* global EventTracking */\n  // Event tracking\n  var TRACK_CATEGORY_INTERACTION = 'Interaction'\n  var TRACK_LABEL_KEYBOARD = 'Keyboard'\n\n  // TODO: Flesh out this dictionary\n  var KEYS = {\n    'left': 37,\n    'right': 39,\n    'enter': 13,\n    'backspace': 8,\n    'delete': 46,\n    'esc': 27,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'a': 65,\n    'b': 66,\n    'c': 67,\n    'd': 68,\n    'e': 69,\n    'f': 70,\n    'g': 71,\n    'h': 72,\n    'i': 73,\n    'j': 74,\n    'k': 75,\n    'l': 76,\n    'm': 77,\n    'n': 78,\n    'o': 79,\n    'p': 80,\n    'q': 81,\n    'r': 82,\n    's': 83,\n    't': 84,\n    'u': 85,\n    'v': 86,\n    'w': 87,\n    'x': 88,\n    'y': 89,\n    'z': 90,\n    // '=': [187, 61],\n    '+': [187, 61, 107], // = or +; 61 for Firefox; 107 for keypad\n    '-': [189, 173, 109], // 109 for keypad; 173 for Firefox\n    '?': 191,\n    '/': 191\n  }\n\n  // Keep track of all registered commands here\n  var inputs = {}\n\n  // Utility functions\n  var noop = function () {}\n  var returnTrue = function () { return true }\n\n  /**\n   *  Initiates keypress manager. Sets a global event listener on the window.\n   *  This should only have to be called once, when the application bootstraps.\n   *\n   *  @public\n   */\n  function init () {\n    // TODO: remove useCapture if we don't need it\n    window.addEventListener('keydown', _onGlobalKeyDown, true)\n  }\n\n  /**\n   *  Registers a key command listener with the Keypress Manager\n   *\n   *  @public\n   *  @example Keypress.register('shift d', { trackMsg: 'Shift-D is pressed' }, function () { console.log('Shift-D is pressed!') })\n   *  @example Keypress.register('esc', hide)\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {object} [options]\n   *    Options that fine tune the behavior of the keypress. If you are unhappy\n   *    with a default setting, they can be overridden here. Note that it is\n   *    possible for overrides to conflict with other parameters, for instance,\n   *    if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   *    Don't do this. This is confusing and I won't guarantee preserving how\n   *    this conflict is addressed.\n   *  @param {(boolean|string)} [options.shiftKey=false]\n   *    If `true`, the `Shift` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `shift` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Shift` is\n   *    pressed.\n   *  @param {(boolean|string)} [options.metaKey=false]\n   *    If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   *    should be pressed in a key combination. This is automatically set to\n   *    `true` if `meta`, `control`, or `command` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Command` or\n   *    `Control` is pressed.\n   *  @param {(boolean|string)} [options.altKey=false]\n   *    If `true`, the `Alt` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `alt` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Alt` is pressed.\n   *  @param {(boolean)} [options.preventDefault=true]\n   *    If `true`, `event.preventDefault()` should be called to prevent the\n   *    key's default behavior.\n   *  @param {(boolean)} [options.stopPropagation=false]\n   *    If `true`, `event.stopPropagation()` should be called to prevent other\n   *    key handlers from triggering. Defaults to `false`, but as a special\n   *    case, this is automatically set to `true` if the command is `esc`.\n   *  @param {(boolean)} [options.requireFocusOnBody=true]\n   *    If `true`, the key handler is not triggered if the browser has focused\n   *    on a specific element, like an input field.  Defaults to `true`, but as\n   *    a special case, this is automatically set to `false` if the command is\n   *    `esc`.\n   *  @param {(string)} [options.trackMsg=null]\n   *    If a string is provided, the action is logged in event tracking when\n   *    triggered.\n   *  @param {(number)} [options.trackValue=null]\n   *    If set, and an event is logged, this fills in the `value` property of a\n   *    tracked event in Google Analytics.\n   *  @param {(boolean)} [options.trackOnce=true]\n   *    If `true`, and an event is logged, further identical actions will not\n   *    be logged.\n   *  @param {(function)} [options.onKeyPress]\n   *    It is possible to set the callback function to execute on key press on\n   *    the `options` object instead of in the `callback` parameter.\n   *  @param {(function)} [options.condition]\n   *    If additional conditions are required before executing a callback\n   *    function after a key is pressed, this function is evaluated. It must\n   *    return a `true` or truthy value for the callback to execute.\n   *  @param {function} [callback]\n   *    Function to execute when key is pressed. Technically, this is optional\n   *    (and you might prefer to set it on `options` instead). If there is no\n   *    callback function the keypress simply does nothing.\n   */\n  function register (commands, options, callback) {\n    // Defaults\n    // For shiftKey, metaKey, and altKey, specifies what it should\n    // match on the event object reported by the browser. For instance,\n    // if event.metaKey is false, it means the command must be executed\n    // only if the meta key (ctrl or command depending on the OS) is not\n    // pressed. (Note that ctrlKey will be internally mapped to behave\n    // the same as metaKey here.) The distinction is strict, pass the\n    // value 'optional' to make the system ignore whether a key is pressed.\n    var defaults = {\n      shiftKey: false,\n      metaKey: false,\n      altKey: false,\n      onKeypress: noop,\n      condition: returnTrue,\n      preventDefault: true,\n      stopPropagation: false,\n      requireFocusOnBody: true,\n      trackMsg: null,\n      trackValue: null,\n      trackOnce: true\n    }\n\n    // Check if the second argument is the options object or the callback function\n    if (typeof arguments[1] === 'object') {\n      options = arguments[1]\n    } else if (typeof arguments[1] === 'function') {\n      // The second argument is the callback function\n      // You cannot pass two callback functions\n      options = {}\n      callback = arguments[1]\n    }\n\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n\n        // Get default settings\n        for (var key in defaults) {\n          if (typeof command[i][key] === 'undefined') {\n            command[i][key] = defaults[key]\n          }\n        }\n\n        // Special case for 'ESC' key; it defaults to global (window) focus\n        if (parseInt(keyCode, 10) === KEYS['esc']) {\n          command[i].requireFocusOnBody = false\n          command[i].stopPropagation = true\n        }\n\n        // Attach callback function to execute\n        if (typeof callback === 'function') {\n          command[i].onKeypress = callback\n        }\n\n        // If options are specified, replace defaults\n        // This basically allows other code to override settings via the\n        // options object - it's dumb, but there's no protection against it,\n        // and who knows, could be useful in edge cases\n        for (var k in options) {\n          if (typeof command[i][k] !== options[k]) {\n            command[i][k] = options[k]\n          }\n        }\n\n        // Add processed commands to module's inputs holder\n        if (typeof inputs[keyCode] === 'undefined') {\n          inputs[keyCode] = []\n        }\n        inputs[keyCode].push(command[i])\n      }\n    }\n  }\n\n  /**\n   *  Deregisters a key command listener, given matching `commands` and\n   *  `callback` parameters.\n   *\n   *  @public\n   *  @example Keypress.deregister('shift d') // Deregisters all triggers for `shift d`\n   *  @example Keypress.deregister('esc', hide) // Deregisters triggers matching callback function `hide` and key `esc`\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {function} [callback]\n   *    Callback function to execute when key is pressed. This is if you want\n   *    to only remove key handlers that match the same callback. If you do not\n   *    provide a callback, all handlers that match `commands` are removed.\n   *  @todo Because of how function equality works, not all functions passed\n   *    in this way result in a true test of equality.\n   */\n  function deregister (commands, callback) {\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n        var items = inputs[keyCode]\n        var x = items.length\n\n        // A reverse while loop quickly removes all duplicates that matches\n        while (x--) {\n          var item = items[x]\n          var matchingCallback = false\n\n          if (item.onKeypress === callback) {\n            matchingCallback = true\n          } else if (typeof callback === 'undefined') {\n            matchingCallback = true\n          }\n\n          // Check for equality for command + function\n          if ((matchingCallback === true) &&\n              (item.shiftKey === command[i].shiftKey || item.shiftKey === 'optional') &&\n              (item.altKey === command[i].altKey || item.altKey === 'optional') &&\n              (item.metaKey === command[i].metaKey || item.metaKey === 'optional')) {\n            // If matches, remove it from the command list.\n            inputs[keyCode].splice(x, 1)\n          }\n        }\n      }\n    }\n  }\n\n\n  /**\n   *  Processes commands\n   *\n   *  @private\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  //@returns object\n   */\n  function _processCommands (commands) {\n    // If a string, force to one-element array, otherwise expect an array of strings\n    if (typeof commands === 'string') {\n      commands = new Array(commands)\n    }\n\n    var commandsObj = {}\n\n    // Process each command input\n    for (var i = 0; i < commands.length; i++) {\n      // Normalize command\n      //  - adjust to lower case\n      //  - replace command/cmd/control/ctrl to meta (this does not remove dupes)\n      var command = commands[i].toLowerCase().replace(/(command|cmd|control|ctrl)/g, 'meta').split(' ')\n      var settings = {\n        shiftKey: false,\n        altKey: false,\n        metaKey: false\n      }\n\n      // Check for existence of modifier keys\n      // Modifier keys are removed from input array\n      var isShift = command.indexOf('shift')\n      if (isShift > -1) {\n        settings.shiftKey = true\n        command.splice(isShift, 1)\n      }\n\n      var isAlt = command.indexOf('alt')\n      if (isAlt > -1) {\n        settings.altKey = true\n        command.splice(isAlt, 1)\n      }\n\n      var isMeta = command.indexOf('meta')\n      if (isMeta > -1) {\n        settings.metaKey = true\n        command.splice(isMeta, 1)\n      }\n\n      // First remaining item in the input array is the key code to test for.\n      // Does not support multi-keys, so rest of input (if provided) is ignored.\n      var keyCode = KEYS[command[0]]\n\n      // Keycodes might be a single number or an array\n      if (keyCode) {\n        var keys = []\n        // If keyCode is a number, convert to single-element array\n        // Can't do a shortcut version of these with numbers :-/\n        if (typeof keyCode === 'number') {\n          keys.push(keyCode)\n        } else if (Array.isArray(keyCode)) {\n          keys = keyCode\n        }\n\n        for (var j = 0; j < keys.length; j++) {\n          settings.keyCode = keys[j]\n          if (typeof commandsObj[keys[j]] === 'undefined') {\n            commandsObj[keys[j]] = []\n          }\n\n          commandsObj[keys[j]].push(settings)\n        }\n      }\n    }\n\n    return commandsObj\n  }\n\n  function _onGlobalKeyDown (event) {\n    var input\n\n    // Find the right command object\n    var commandsForKeyCode = inputs[event.keyCode]\n    if (!commandsForKeyCode || commandsForKeyCode.length === 0) return\n\n    // Check if the right meta keys are down\n    for (var i = 0; i < commandsForKeyCode.length; i++) {\n      var item = commandsForKeyCode[i]\n      if ((item.shiftKey === event.shiftKey || item.shiftKey === 'optional') &&\n          (item.altKey === event.altKey || item.altKey === 'optional') &&\n          (item.metaKey === event.metaKey || item.metaKey === 'optional')) {\n        input = item\n      }\n    }\n\n    // Execute input's callback, if found\n    if (input) {\n      _execute(input, event)\n    }\n  }\n\n  /**\n   *  Executes an input's callback function\n   *\n   *  @private\n   *  @param {object} input - The input object to execute\n   *  @param {Event} [event] - The browser's `Event` object created when `keydown` is fired\n   */\n  function _execute (input, event) {\n    // Check if condition is satisfied\n    if (!input.condition()) return\n\n    // Check if focus is on the correct place\n    if (input.requireFocusOnBody === true && _isFocusOnBody() === false) return\n\n    if (event && input.preventDefault) {\n      event.preventDefault()\n    }\n    if (event && input.stopPropagation) {\n      event.stopPropagation()\n    }\n    if (input.trackMsg) {\n      EventTracking.track(TRACK_CATEGORY_INTERACTION, input.trackMsg, TRACK_LABEL_KEYBOARD, input.trackValue, input.trackOnce)\n    }\n\n    // Execute callback\n    input.onKeypress()\n  }\n\n  // Utility function\n  function _isFocusOnBody () {\n    return document.activeElement === document.body\n  }\n\n  return {\n    init: init,\n    register: register,\n    deregister: deregister,\n    inputs: inputs,\n    _proc: _processCommands\n  }\n\n}"
    },
    "access": "public",
    "examples": [
      "Keypress.deregister(<span class=\"hljs-string\">'shift d'</span>) <span class=\"hljs-comment\">// Deregisters all triggers for `shift d`</span>",
      "Keypress.deregister(<span class=\"hljs-string\">'esc'</span>, hide) <span class=\"hljs-comment\">// Deregisters triggers matching callback function `hide` and key `esc`</span>"
    ],
    "params": [
      {
        "title": "param",
        "description": "Human readable key or key combination to listen for, in the form of \"a\"\n   or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`",
        "lineNumber": 7,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ]
            }
          ]
        },
        "name": "commands"
      },
      {
        "title": "param",
        "description": "Callback function to execute when key is pressed. This is if you want\n   to only remove key handlers that match the same callback. If you do not\n   provide a callback, all handlers that match `commands` are removed.",
        "lineNumber": 11,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "function"
          }
        },
        "name": "callback"
      }
    ],
    "name": "deregister",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "deregister"
    ]
  },
  {
    "description": "Initiates keypress manager. Sets a global event listener on the window.\n This should only have to be called once, when the application bootstraps.",
    "tags": [
      {
        "title": "public",
        "description": null,
        "lineNumber": 4,
        "type": null
      },
      {
        "title": "name",
        "name": "init"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 82,
        "column": 2
      },
      "end": {
        "line": 87,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 88,
          "column": 2
        },
        "end": {
          "line": 91,
          "column": 3
        }
      },
      "file": "/Users/lou/Repositories/codeforamerica/streetmix/assets/js/app/keypress.js",
      "code": "{\n  'use strict'\n\n  /* global EventTracking */\n  // Event tracking\n  var TRACK_CATEGORY_INTERACTION = 'Interaction'\n  var TRACK_LABEL_KEYBOARD = 'Keyboard'\n\n  // TODO: Flesh out this dictionary\n  var KEYS = {\n    'left': 37,\n    'right': 39,\n    'enter': 13,\n    'backspace': 8,\n    'delete': 46,\n    'esc': 27,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'a': 65,\n    'b': 66,\n    'c': 67,\n    'd': 68,\n    'e': 69,\n    'f': 70,\n    'g': 71,\n    'h': 72,\n    'i': 73,\n    'j': 74,\n    'k': 75,\n    'l': 76,\n    'm': 77,\n    'n': 78,\n    'o': 79,\n    'p': 80,\n    'q': 81,\n    'r': 82,\n    's': 83,\n    't': 84,\n    'u': 85,\n    'v': 86,\n    'w': 87,\n    'x': 88,\n    'y': 89,\n    'z': 90,\n    // '=': [187, 61],\n    '+': [187, 61, 107], // = or +; 61 for Firefox; 107 for keypad\n    '-': [189, 173, 109], // 109 for keypad; 173 for Firefox\n    '?': 191,\n    '/': 191\n  }\n\n  // Keep track of all registered commands here\n  var inputs = {}\n\n  // Utility functions\n  var noop = function () {}\n  var returnTrue = function () { return true }\n\n  /**\n   *  Initiates keypress manager. Sets a global event listener on the window.\n   *  This should only have to be called once, when the application bootstraps.\n   *\n   *  @public\n   */\n  function init () {\n    // TODO: remove useCapture if we don't need it\n    window.addEventListener('keydown', _onGlobalKeyDown, true)\n  }\n\n  /**\n   *  Registers a key command listener with the Keypress Manager\n   *\n   *  @public\n   *  @example Keypress.register('shift d', { trackMsg: 'Shift-D is pressed' }, function () { console.log('Shift-D is pressed!') })\n   *  @example Keypress.register('esc', hide)\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {object} [options]\n   *    Options that fine tune the behavior of the keypress. If you are unhappy\n   *    with a default setting, they can be overridden here. Note that it is\n   *    possible for overrides to conflict with other parameters, for instance,\n   *    if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   *    Don't do this. This is confusing and I won't guarantee preserving how\n   *    this conflict is addressed.\n   *  @param {(boolean|string)} [options.shiftKey=false]\n   *    If `true`, the `Shift` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `shift` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Shift` is\n   *    pressed.\n   *  @param {(boolean|string)} [options.metaKey=false]\n   *    If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   *    should be pressed in a key combination. This is automatically set to\n   *    `true` if `meta`, `control`, or `command` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Command` or\n   *    `Control` is pressed.\n   *  @param {(boolean|string)} [options.altKey=false]\n   *    If `true`, the `Alt` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `alt` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Alt` is pressed.\n   *  @param {(boolean)} [options.preventDefault=true]\n   *    If `true`, `event.preventDefault()` should be called to prevent the\n   *    key's default behavior.\n   *  @param {(boolean)} [options.stopPropagation=false]\n   *    If `true`, `event.stopPropagation()` should be called to prevent other\n   *    key handlers from triggering. Defaults to `false`, but as a special\n   *    case, this is automatically set to `true` if the command is `esc`.\n   *  @param {(boolean)} [options.requireFocusOnBody=true]\n   *    If `true`, the key handler is not triggered if the browser has focused\n   *    on a specific element, like an input field.  Defaults to `true`, but as\n   *    a special case, this is automatically set to `false` if the command is\n   *    `esc`.\n   *  @param {(string)} [options.trackMsg=null]\n   *    If a string is provided, the action is logged in event tracking when\n   *    triggered.\n   *  @param {(number)} [options.trackValue=null]\n   *    If set, and an event is logged, this fills in the `value` property of a\n   *    tracked event in Google Analytics.\n   *  @param {(boolean)} [options.trackOnce=true]\n   *    If `true`, and an event is logged, further identical actions will not\n   *    be logged.\n   *  @param {(function)} [options.onKeyPress]\n   *    It is possible to set the callback function to execute on key press on\n   *    the `options` object instead of in the `callback` parameter.\n   *  @param {(function)} [options.condition]\n   *    If additional conditions are required before executing a callback\n   *    function after a key is pressed, this function is evaluated. It must\n   *    return a `true` or truthy value for the callback to execute.\n   *  @param {function} [callback]\n   *    Function to execute when key is pressed. Technically, this is optional\n   *    (and you might prefer to set it on `options` instead). If there is no\n   *    callback function the keypress simply does nothing.\n   */\n  function register (commands, options, callback) {\n    // Defaults\n    // For shiftKey, metaKey, and altKey, specifies what it should\n    // match on the event object reported by the browser. For instance,\n    // if event.metaKey is false, it means the command must be executed\n    // only if the meta key (ctrl or command depending on the OS) is not\n    // pressed. (Note that ctrlKey will be internally mapped to behave\n    // the same as metaKey here.) The distinction is strict, pass the\n    // value 'optional' to make the system ignore whether a key is pressed.\n    var defaults = {\n      shiftKey: false,\n      metaKey: false,\n      altKey: false,\n      onKeypress: noop,\n      condition: returnTrue,\n      preventDefault: true,\n      stopPropagation: false,\n      requireFocusOnBody: true,\n      trackMsg: null,\n      trackValue: null,\n      trackOnce: true\n    }\n\n    // Check if the second argument is the options object or the callback function\n    if (typeof arguments[1] === 'object') {\n      options = arguments[1]\n    } else if (typeof arguments[1] === 'function') {\n      // The second argument is the callback function\n      // You cannot pass two callback functions\n      options = {}\n      callback = arguments[1]\n    }\n\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n\n        // Get default settings\n        for (var key in defaults) {\n          if (typeof command[i][key] === 'undefined') {\n            command[i][key] = defaults[key]\n          }\n        }\n\n        // Special case for 'ESC' key; it defaults to global (window) focus\n        if (parseInt(keyCode, 10) === KEYS['esc']) {\n          command[i].requireFocusOnBody = false\n          command[i].stopPropagation = true\n        }\n\n        // Attach callback function to execute\n        if (typeof callback === 'function') {\n          command[i].onKeypress = callback\n        }\n\n        // If options are specified, replace defaults\n        // This basically allows other code to override settings via the\n        // options object - it's dumb, but there's no protection against it,\n        // and who knows, could be useful in edge cases\n        for (var k in options) {\n          if (typeof command[i][k] !== options[k]) {\n            command[i][k] = options[k]\n          }\n        }\n\n        // Add processed commands to module's inputs holder\n        if (typeof inputs[keyCode] === 'undefined') {\n          inputs[keyCode] = []\n        }\n        inputs[keyCode].push(command[i])\n      }\n    }\n  }\n\n  /**\n   *  Deregisters a key command listener, given matching `commands` and\n   *  `callback` parameters.\n   *\n   *  @public\n   *  @example Keypress.deregister('shift d') // Deregisters all triggers for `shift d`\n   *  @example Keypress.deregister('esc', hide) // Deregisters triggers matching callback function `hide` and key `esc`\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {function} [callback]\n   *    Callback function to execute when key is pressed. This is if you want\n   *    to only remove key handlers that match the same callback. If you do not\n   *    provide a callback, all handlers that match `commands` are removed.\n   *  @todo Because of how function equality works, not all functions passed\n   *    in this way result in a true test of equality.\n   */\n  function deregister (commands, callback) {\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n        var items = inputs[keyCode]\n        var x = items.length\n\n        // A reverse while loop quickly removes all duplicates that matches\n        while (x--) {\n          var item = items[x]\n          var matchingCallback = false\n\n          if (item.onKeypress === callback) {\n            matchingCallback = true\n          } else if (typeof callback === 'undefined') {\n            matchingCallback = true\n          }\n\n          // Check for equality for command + function\n          if ((matchingCallback === true) &&\n              (item.shiftKey === command[i].shiftKey || item.shiftKey === 'optional') &&\n              (item.altKey === command[i].altKey || item.altKey === 'optional') &&\n              (item.metaKey === command[i].metaKey || item.metaKey === 'optional')) {\n            // If matches, remove it from the command list.\n            inputs[keyCode].splice(x, 1)\n          }\n        }\n      }\n    }\n  }\n\n\n  /**\n   *  Processes commands\n   *\n   *  @private\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  //@returns object\n   */\n  function _processCommands (commands) {\n    // If a string, force to one-element array, otherwise expect an array of strings\n    if (typeof commands === 'string') {\n      commands = new Array(commands)\n    }\n\n    var commandsObj = {}\n\n    // Process each command input\n    for (var i = 0; i < commands.length; i++) {\n      // Normalize command\n      //  - adjust to lower case\n      //  - replace command/cmd/control/ctrl to meta (this does not remove dupes)\n      var command = commands[i].toLowerCase().replace(/(command|cmd|control|ctrl)/g, 'meta').split(' ')\n      var settings = {\n        shiftKey: false,\n        altKey: false,\n        metaKey: false\n      }\n\n      // Check for existence of modifier keys\n      // Modifier keys are removed from input array\n      var isShift = command.indexOf('shift')\n      if (isShift > -1) {\n        settings.shiftKey = true\n        command.splice(isShift, 1)\n      }\n\n      var isAlt = command.indexOf('alt')\n      if (isAlt > -1) {\n        settings.altKey = true\n        command.splice(isAlt, 1)\n      }\n\n      var isMeta = command.indexOf('meta')\n      if (isMeta > -1) {\n        settings.metaKey = true\n        command.splice(isMeta, 1)\n      }\n\n      // First remaining item in the input array is the key code to test for.\n      // Does not support multi-keys, so rest of input (if provided) is ignored.\n      var keyCode = KEYS[command[0]]\n\n      // Keycodes might be a single number or an array\n      if (keyCode) {\n        var keys = []\n        // If keyCode is a number, convert to single-element array\n        // Can't do a shortcut version of these with numbers :-/\n        if (typeof keyCode === 'number') {\n          keys.push(keyCode)\n        } else if (Array.isArray(keyCode)) {\n          keys = keyCode\n        }\n\n        for (var j = 0; j < keys.length; j++) {\n          settings.keyCode = keys[j]\n          if (typeof commandsObj[keys[j]] === 'undefined') {\n            commandsObj[keys[j]] = []\n          }\n\n          commandsObj[keys[j]].push(settings)\n        }\n      }\n    }\n\n    return commandsObj\n  }\n\n  function _onGlobalKeyDown (event) {\n    var input\n\n    // Find the right command object\n    var commandsForKeyCode = inputs[event.keyCode]\n    if (!commandsForKeyCode || commandsForKeyCode.length === 0) return\n\n    // Check if the right meta keys are down\n    for (var i = 0; i < commandsForKeyCode.length; i++) {\n      var item = commandsForKeyCode[i]\n      if ((item.shiftKey === event.shiftKey || item.shiftKey === 'optional') &&\n          (item.altKey === event.altKey || item.altKey === 'optional') &&\n          (item.metaKey === event.metaKey || item.metaKey === 'optional')) {\n        input = item\n      }\n    }\n\n    // Execute input's callback, if found\n    if (input) {\n      _execute(input, event)\n    }\n  }\n\n  /**\n   *  Executes an input's callback function\n   *\n   *  @private\n   *  @param {object} input - The input object to execute\n   *  @param {Event} [event] - The browser's `Event` object created when `keydown` is fired\n   */\n  function _execute (input, event) {\n    // Check if condition is satisfied\n    if (!input.condition()) return\n\n    // Check if focus is on the correct place\n    if (input.requireFocusOnBody === true && _isFocusOnBody() === false) return\n\n    if (event && input.preventDefault) {\n      event.preventDefault()\n    }\n    if (event && input.stopPropagation) {\n      event.stopPropagation()\n    }\n    if (input.trackMsg) {\n      EventTracking.track(TRACK_CATEGORY_INTERACTION, input.trackMsg, TRACK_LABEL_KEYBOARD, input.trackValue, input.trackOnce)\n    }\n\n    // Execute callback\n    input.onKeypress()\n  }\n\n  // Utility function\n  function _isFocusOnBody () {\n    return document.activeElement === document.body\n  }\n\n  return {\n    init: init,\n    register: register,\n    deregister: deregister,\n    inputs: inputs,\n    _proc: _processCommands\n  }\n\n}"
    },
    "access": "public",
    "name": "init",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "init"
    ]
  },
  {
    "description": "Keypress (singleton)\n\n Handles registration, removal, and processing of keyboard inputs.\n Some inspiration:\n   - Mousetrap.js (https://craig.is/killing/mice)\n   - Keypress.js (http://dmauro.github.io/Keypress/)\n   - keymaster.js (https://github.com/madrobby/keymaster)",
    "tags": [
      {
        "title": "module",
        "description": null,
        "lineNumber": 9,
        "type": null,
        "name": "Keypress"
      },
      {
        "title": "requires",
        "description": null,
        "lineNumber": 10,
        "name": "EventTracking"
      },
      {
        "title": "exports",
        "description": "Keypress",
        "lineNumber": 11
      },
      {
        "title": "name",
        "name": "Keypress"
      },
      {
        "title": "kind",
        "kind": "module"
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 13,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 16,
          "column": 0
        },
        "end": {
          "line": 437,
          "column": 0
        }
      },
      "file": "/Users/lou/Repositories/codeforamerica/streetmix/assets/js/app/keypress.js",
      "code": "var Keypress = (function () {\n  'use strict'\n\n  /* global EventTracking */\n  // Event tracking\n  var TRACK_CATEGORY_INTERACTION = 'Interaction'\n  var TRACK_LABEL_KEYBOARD = 'Keyboard'\n\n  // TODO: Flesh out this dictionary\n  var KEYS = {\n    'left': 37,\n    'right': 39,\n    'enter': 13,\n    'backspace': 8,\n    'delete': 46,\n    'esc': 27,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'a': 65,\n    'b': 66,\n    'c': 67,\n    'd': 68,\n    'e': 69,\n    'f': 70,\n    'g': 71,\n    'h': 72,\n    'i': 73,\n    'j': 74,\n    'k': 75,\n    'l': 76,\n    'm': 77,\n    'n': 78,\n    'o': 79,\n    'p': 80,\n    'q': 81,\n    'r': 82,\n    's': 83,\n    't': 84,\n    'u': 85,\n    'v': 86,\n    'w': 87,\n    'x': 88,\n    'y': 89,\n    'z': 90,\n    // '=': [187, 61],\n    '+': [187, 61, 107], // = or +; 61 for Firefox; 107 for keypad\n    '-': [189, 173, 109], // 109 for keypad; 173 for Firefox\n    '?': 191,\n    '/': 191\n  }\n\n  // Keep track of all registered commands here\n  var inputs = {}\n\n  // Utility functions\n  var noop = function () {}\n  var returnTrue = function () { return true }\n\n  /**\n   *  Initiates keypress manager. Sets a global event listener on the window.\n   *  This should only have to be called once, when the application bootstraps.\n   *\n   *  @public\n   */\n  function init () {\n    // TODO: remove useCapture if we don't need it\n    window.addEventListener('keydown', _onGlobalKeyDown, true)\n  }\n\n  /**\n   *  Registers a key command listener with the Keypress Manager\n   *\n   *  @public\n   *  @example Keypress.register('shift d', { trackMsg: 'Shift-D is pressed' }, function () { console.log('Shift-D is pressed!') })\n   *  @example Keypress.register('esc', hide)\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {object} [options]\n   *    Options that fine tune the behavior of the keypress. If you are unhappy\n   *    with a default setting, they can be overridden here. Note that it is\n   *    possible for overrides to conflict with other parameters, for instance,\n   *    if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   *    Don't do this. This is confusing and I won't guarantee preserving how\n   *    this conflict is addressed.\n   *  @param {(boolean|string)} [options.shiftKey=false]\n   *    If `true`, the `Shift` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `shift` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Shift` is\n   *    pressed.\n   *  @param {(boolean|string)} [options.metaKey=false]\n   *    If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   *    should be pressed in a key combination. This is automatically set to\n   *    `true` if `meta`, `control`, or `command` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Command` or\n   *    `Control` is pressed.\n   *  @param {(boolean|string)} [options.altKey=false]\n   *    If `true`, the `Alt` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `alt` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Alt` is pressed.\n   *  @param {(boolean)} [options.preventDefault=true]\n   *    If `true`, `event.preventDefault()` should be called to prevent the\n   *    key's default behavior.\n   *  @param {(boolean)} [options.stopPropagation=false]\n   *    If `true`, `event.stopPropagation()` should be called to prevent other\n   *    key handlers from triggering. Defaults to `false`, but as a special\n   *    case, this is automatically set to `true` if the command is `esc`.\n   *  @param {(boolean)} [options.requireFocusOnBody=true]\n   *    If `true`, the key handler is not triggered if the browser has focused\n   *    on a specific element, like an input field.  Defaults to `true`, but as\n   *    a special case, this is automatically set to `false` if the command is\n   *    `esc`.\n   *  @param {(string)} [options.trackMsg=null]\n   *    If a string is provided, the action is logged in event tracking when\n   *    triggered.\n   *  @param {(number)} [options.trackValue=null]\n   *    If set, and an event is logged, this fills in the `value` property of a\n   *    tracked event in Google Analytics.\n   *  @param {(boolean)} [options.trackOnce=true]\n   *    If `true`, and an event is logged, further identical actions will not\n   *    be logged.\n   *  @param {(function)} [options.onKeyPress]\n   *    It is possible to set the callback function to execute on key press on\n   *    the `options` object instead of in the `callback` parameter.\n   *  @param {(function)} [options.condition]\n   *    If additional conditions are required before executing a callback\n   *    function after a key is pressed, this function is evaluated. It must\n   *    return a `true` or truthy value for the callback to execute.\n   *  @param {function} [callback]\n   *    Function to execute when key is pressed. Technically, this is optional\n   *    (and you might prefer to set it on `options` instead). If there is no\n   *    callback function the keypress simply does nothing.\n   */\n  function register (commands, options, callback) {\n    // Defaults\n    // For shiftKey, metaKey, and altKey, specifies what it should\n    // match on the event object reported by the browser. For instance,\n    // if event.metaKey is false, it means the command must be executed\n    // only if the meta key (ctrl or command depending on the OS) is not\n    // pressed. (Note that ctrlKey will be internally mapped to behave\n    // the same as metaKey here.) The distinction is strict, pass the\n    // value 'optional' to make the system ignore whether a key is pressed.\n    var defaults = {\n      shiftKey: false,\n      metaKey: false,\n      altKey: false,\n      onKeypress: noop,\n      condition: returnTrue,\n      preventDefault: true,\n      stopPropagation: false,\n      requireFocusOnBody: true,\n      trackMsg: null,\n      trackValue: null,\n      trackOnce: true\n    }\n\n    // Check if the second argument is the options object or the callback function\n    if (typeof arguments[1] === 'object') {\n      options = arguments[1]\n    } else if (typeof arguments[1] === 'function') {\n      // The second argument is the callback function\n      // You cannot pass two callback functions\n      options = {}\n      callback = arguments[1]\n    }\n\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n\n        // Get default settings\n        for (var key in defaults) {\n          if (typeof command[i][key] === 'undefined') {\n            command[i][key] = defaults[key]\n          }\n        }\n\n        // Special case for 'ESC' key; it defaults to global (window) focus\n        if (parseInt(keyCode, 10) === KEYS['esc']) {\n          command[i].requireFocusOnBody = false\n          command[i].stopPropagation = true\n        }\n\n        // Attach callback function to execute\n        if (typeof callback === 'function') {\n          command[i].onKeypress = callback\n        }\n\n        // If options are specified, replace defaults\n        // This basically allows other code to override settings via the\n        // options object - it's dumb, but there's no protection against it,\n        // and who knows, could be useful in edge cases\n        for (var k in options) {\n          if (typeof command[i][k] !== options[k]) {\n            command[i][k] = options[k]\n          }\n        }\n\n        // Add processed commands to module's inputs holder\n        if (typeof inputs[keyCode] === 'undefined') {\n          inputs[keyCode] = []\n        }\n        inputs[keyCode].push(command[i])\n      }\n    }\n  }\n\n  /**\n   *  Deregisters a key command listener, given matching `commands` and\n   *  `callback` parameters.\n   *\n   *  @public\n   *  @example Keypress.deregister('shift d') // Deregisters all triggers for `shift d`\n   *  @example Keypress.deregister('esc', hide) // Deregisters triggers matching callback function `hide` and key `esc`\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {function} [callback]\n   *    Callback function to execute when key is pressed. This is if you want\n   *    to only remove key handlers that match the same callback. If you do not\n   *    provide a callback, all handlers that match `commands` are removed.\n   *  @todo Because of how function equality works, not all functions passed\n   *    in this way result in a true test of equality.\n   */\n  function deregister (commands, callback) {\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n        var items = inputs[keyCode]\n        var x = items.length\n\n        // A reverse while loop quickly removes all duplicates that matches\n        while (x--) {\n          var item = items[x]\n          var matchingCallback = false\n\n          if (item.onKeypress === callback) {\n            matchingCallback = true\n          } else if (typeof callback === 'undefined') {\n            matchingCallback = true\n          }\n\n          // Check for equality for command + function\n          if ((matchingCallback === true) &&\n              (item.shiftKey === command[i].shiftKey || item.shiftKey === 'optional') &&\n              (item.altKey === command[i].altKey || item.altKey === 'optional') &&\n              (item.metaKey === command[i].metaKey || item.metaKey === 'optional')) {\n            // If matches, remove it from the command list.\n            inputs[keyCode].splice(x, 1)\n          }\n        }\n      }\n    }\n  }\n\n\n  /**\n   *  Processes commands\n   *\n   *  @private\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  //@returns object\n   */\n  function _processCommands (commands) {\n    // If a string, force to one-element array, otherwise expect an array of strings\n    if (typeof commands === 'string') {\n      commands = new Array(commands)\n    }\n\n    var commandsObj = {}\n\n    // Process each command input\n    for (var i = 0; i < commands.length; i++) {\n      // Normalize command\n      //  - adjust to lower case\n      //  - replace command/cmd/control/ctrl to meta (this does not remove dupes)\n      var command = commands[i].toLowerCase().replace(/(command|cmd|control|ctrl)/g, 'meta').split(' ')\n      var settings = {\n        shiftKey: false,\n        altKey: false,\n        metaKey: false\n      }\n\n      // Check for existence of modifier keys\n      // Modifier keys are removed from input array\n      var isShift = command.indexOf('shift')\n      if (isShift > -1) {\n        settings.shiftKey = true\n        command.splice(isShift, 1)\n      }\n\n      var isAlt = command.indexOf('alt')\n      if (isAlt > -1) {\n        settings.altKey = true\n        command.splice(isAlt, 1)\n      }\n\n      var isMeta = command.indexOf('meta')\n      if (isMeta > -1) {\n        settings.metaKey = true\n        command.splice(isMeta, 1)\n      }\n\n      // First remaining item in the input array is the key code to test for.\n      // Does not support multi-keys, so rest of input (if provided) is ignored.\n      var keyCode = KEYS[command[0]]\n\n      // Keycodes might be a single number or an array\n      if (keyCode) {\n        var keys = []\n        // If keyCode is a number, convert to single-element array\n        // Can't do a shortcut version of these with numbers :-/\n        if (typeof keyCode === 'number') {\n          keys.push(keyCode)\n        } else if (Array.isArray(keyCode)) {\n          keys = keyCode\n        }\n\n        for (var j = 0; j < keys.length; j++) {\n          settings.keyCode = keys[j]\n          if (typeof commandsObj[keys[j]] === 'undefined') {\n            commandsObj[keys[j]] = []\n          }\n\n          commandsObj[keys[j]].push(settings)\n        }\n      }\n    }\n\n    return commandsObj\n  }\n\n  function _onGlobalKeyDown (event) {\n    var input\n\n    // Find the right command object\n    var commandsForKeyCode = inputs[event.keyCode]\n    if (!commandsForKeyCode || commandsForKeyCode.length === 0) return\n\n    // Check if the right meta keys are down\n    for (var i = 0; i < commandsForKeyCode.length; i++) {\n      var item = commandsForKeyCode[i]\n      if ((item.shiftKey === event.shiftKey || item.shiftKey === 'optional') &&\n          (item.altKey === event.altKey || item.altKey === 'optional') &&\n          (item.metaKey === event.metaKey || item.metaKey === 'optional')) {\n        input = item\n      }\n    }\n\n    // Execute input's callback, if found\n    if (input) {\n      _execute(input, event)\n    }\n  }\n\n  /**\n   *  Executes an input's callback function\n   *\n   *  @private\n   *  @param {object} input - The input object to execute\n   *  @param {Event} [event] - The browser's `Event` object created when `keydown` is fired\n   */\n  function _execute (input, event) {\n    // Check if condition is satisfied\n    if (!input.condition()) return\n\n    // Check if focus is on the correct place\n    if (input.requireFocusOnBody === true && _isFocusOnBody() === false) return\n\n    if (event && input.preventDefault) {\n      event.preventDefault()\n    }\n    if (event && input.stopPropagation) {\n      event.stopPropagation()\n    }\n    if (input.trackMsg) {\n      EventTracking.track(TRACK_CATEGORY_INTERACTION, input.trackMsg, TRACK_LABEL_KEYBOARD, input.trackValue, input.trackOnce)\n    }\n\n    // Execute callback\n    input.onKeypress()\n  }\n\n  // Utility function\n  function _isFocusOnBody () {\n    return document.activeElement === document.body\n  }\n\n  return {\n    init: init,\n    register: register,\n    deregister: deregister,\n    inputs: inputs,\n    _proc: _processCommands\n  }\n\n})()\n"
    },
    "name": "Keypress",
    "kind": "module",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "Keypress"
    ]
  },
  {
    "description": "Registers a key command listener with the Keypress Manager",
    "tags": [
      {
        "title": "public",
        "description": null,
        "lineNumber": 3,
        "type": null
      },
      {
        "title": "example",
        "description": "Keypress.register('shift d', { trackMsg: 'Shift-D is pressed' }, function () { console.log('Shift-D is pressed!') })",
        "lineNumber": 4
      },
      {
        "title": "example",
        "description": "Keypress.register('esc', hide)",
        "lineNumber": 5
      },
      {
        "title": "param",
        "description": "Human readable key or key combination to listen for, in the form of \"a\"\n   or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ]
            }
          ]
        },
        "name": "commands"
      },
      {
        "title": "param",
        "description": "Options that fine tune the behavior of the keypress. If you are unhappy\n   with a default setting, they can be overridden here. Note that it is\n   possible for overrides to conflict with other parameters, for instance,\n   if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   Don't do this. This is confusing and I won't guarantee preserving how\n   this conflict is addressed.",
        "lineNumber": 10,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "object"
          }
        },
        "name": "options",
        "properties": [
          {
            "title": "param",
            "description": "If `true`, the `Shift` key should be pressed in a key combination. This\n   is automatically set to `true` if `shift` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Shift` is\n   pressed.",
            "lineNumber": 17,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.shiftKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   should be pressed in a key combination. This is automatically set to\n   `true` if `meta`, `control`, or `command` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Command` or\n   `Control` is pressed.",
            "lineNumber": 23,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.metaKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the `Alt` key should be pressed in a key combination. This\n   is automatically set to `true` if `alt` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Alt` is pressed.",
            "lineNumber": 30,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.altKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, `event.preventDefault()` should be called to prevent the\n   key's default behavior.",
            "lineNumber": 35,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.preventDefault",
            "default": "true"
          },
          {
            "title": "param",
            "description": "If `true`, `event.stopPropagation()` should be called to prevent other\n   key handlers from triggering. Defaults to `false`, but as a special\n   case, this is automatically set to `true` if the command is `esc`.",
            "lineNumber": 38,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.stopPropagation",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the key handler is not triggered if the browser has focused\n   on a specific element, like an input field.  Defaults to `true`, but as\n   a special case, this is automatically set to `false` if the command is\n   `esc`.",
            "lineNumber": 42,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.requireFocusOnBody",
            "default": "true"
          },
          {
            "title": "param",
            "description": "If a string is provided, the action is logged in event tracking when\n   triggered.",
            "lineNumber": 47,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.trackMsg",
            "default": "null"
          },
          {
            "title": "param",
            "description": "If set, and an event is logged, this fills in the `value` property of a\n   tracked event in Google Analytics.",
            "lineNumber": 50,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              }
            },
            "name": "options.trackValue",
            "default": "null"
          },
          {
            "title": "param",
            "description": "If `true`, and an event is logged, further identical actions will not\n   be logged.",
            "lineNumber": 53,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.trackOnce",
            "default": "true"
          },
          {
            "title": "param",
            "description": "It is possible to set the callback function to execute on key press on\n   the `options` object instead of in the `callback` parameter.",
            "lineNumber": 56,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "function"
                  }
                ]
              }
            },
            "name": "options.onKeyPress"
          },
          {
            "title": "param",
            "description": "If additional conditions are required before executing a callback\n   function after a key is pressed, this function is evaluated. It must\n   return a `true` or truthy value for the callback to execute.",
            "lineNumber": 59,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "function"
                  }
                ]
              }
            },
            "name": "options.condition"
          }
        ]
      },
      {
        "title": "param",
        "description": "If `true`, the `Shift` key should be pressed in a key combination. This\n   is automatically set to `true` if `shift` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Shift` is\n   pressed.",
        "lineNumber": 17,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "options.shiftKey",
        "default": "false"
      },
      {
        "title": "param",
        "description": "If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   should be pressed in a key combination. This is automatically set to\n   `true` if `meta`, `control`, or `command` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Command` or\n   `Control` is pressed.",
        "lineNumber": 23,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "options.metaKey",
        "default": "false"
      },
      {
        "title": "param",
        "description": "If `true`, the `Alt` key should be pressed in a key combination. This\n   is automatically set to `true` if `alt` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Alt` is pressed.",
        "lineNumber": 30,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              },
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "options.altKey",
        "default": "false"
      },
      {
        "title": "param",
        "description": "If `true`, `event.preventDefault()` should be called to prevent the\n   key's default behavior.",
        "lineNumber": 35,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              }
            ]
          }
        },
        "name": "options.preventDefault",
        "default": "true"
      },
      {
        "title": "param",
        "description": "If `true`, `event.stopPropagation()` should be called to prevent other\n   key handlers from triggering. Defaults to `false`, but as a special\n   case, this is automatically set to `true` if the command is `esc`.",
        "lineNumber": 38,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              }
            ]
          }
        },
        "name": "options.stopPropagation",
        "default": "false"
      },
      {
        "title": "param",
        "description": "If `true`, the key handler is not triggered if the browser has focused\n   on a specific element, like an input field.  Defaults to `true`, but as\n   a special case, this is automatically set to `false` if the command is\n   `esc`.",
        "lineNumber": 42,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              }
            ]
          }
        },
        "name": "options.requireFocusOnBody",
        "default": "true"
      },
      {
        "title": "param",
        "description": "If a string is provided, the action is logged in event tracking when\n   triggered.",
        "lineNumber": 47,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "string"
              }
            ]
          }
        },
        "name": "options.trackMsg",
        "default": "null"
      },
      {
        "title": "param",
        "description": "If set, and an event is logged, this fills in the `value` property of a\n   tracked event in Google Analytics.",
        "lineNumber": 50,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "number"
              }
            ]
          }
        },
        "name": "options.trackValue",
        "default": "null"
      },
      {
        "title": "param",
        "description": "If `true`, and an event is logged, further identical actions will not\n   be logged.",
        "lineNumber": 53,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "boolean"
              }
            ]
          }
        },
        "name": "options.trackOnce",
        "default": "true"
      },
      {
        "title": "param",
        "description": "It is possible to set the callback function to execute on key press on\n   the `options` object instead of in the `callback` parameter.",
        "lineNumber": 56,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "function"
              }
            ]
          }
        },
        "name": "options.onKeyPress"
      },
      {
        "title": "param",
        "description": "If additional conditions are required before executing a callback\n   function after a key is pressed, this function is evaluated. It must\n   return a `true` or truthy value for the callback to execute.",
        "lineNumber": 59,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "UnionType",
            "elements": [
              {
                "type": "NameExpression",
                "name": "function"
              }
            ]
          }
        },
        "name": "options.condition"
      },
      {
        "title": "param",
        "description": "Function to execute when key is pressed. Technically, this is optional\n   (and you might prefer to set it on `options` instead). If there is no\n   callback function the keypress simply does nothing.",
        "lineNumber": 63,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "function"
          }
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "register"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 93,
        "column": 2
      },
      "end": {
        "line": 160,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 161,
          "column": 2
        },
        "end": {
          "line": 237,
          "column": 3
        }
      },
      "file": "/Users/lou/Repositories/codeforamerica/streetmix/assets/js/app/keypress.js",
      "code": "{\n  'use strict'\n\n  /* global EventTracking */\n  // Event tracking\n  var TRACK_CATEGORY_INTERACTION = 'Interaction'\n  var TRACK_LABEL_KEYBOARD = 'Keyboard'\n\n  // TODO: Flesh out this dictionary\n  var KEYS = {\n    'left': 37,\n    'right': 39,\n    'enter': 13,\n    'backspace': 8,\n    'delete': 46,\n    'esc': 27,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'a': 65,\n    'b': 66,\n    'c': 67,\n    'd': 68,\n    'e': 69,\n    'f': 70,\n    'g': 71,\n    'h': 72,\n    'i': 73,\n    'j': 74,\n    'k': 75,\n    'l': 76,\n    'm': 77,\n    'n': 78,\n    'o': 79,\n    'p': 80,\n    'q': 81,\n    'r': 82,\n    's': 83,\n    't': 84,\n    'u': 85,\n    'v': 86,\n    'w': 87,\n    'x': 88,\n    'y': 89,\n    'z': 90,\n    // '=': [187, 61],\n    '+': [187, 61, 107], // = or +; 61 for Firefox; 107 for keypad\n    '-': [189, 173, 109], // 109 for keypad; 173 for Firefox\n    '?': 191,\n    '/': 191\n  }\n\n  // Keep track of all registered commands here\n  var inputs = {}\n\n  // Utility functions\n  var noop = function () {}\n  var returnTrue = function () { return true }\n\n  /**\n   *  Initiates keypress manager. Sets a global event listener on the window.\n   *  This should only have to be called once, when the application bootstraps.\n   *\n   *  @public\n   */\n  function init () {\n    // TODO: remove useCapture if we don't need it\n    window.addEventListener('keydown', _onGlobalKeyDown, true)\n  }\n\n  /**\n   *  Registers a key command listener with the Keypress Manager\n   *\n   *  @public\n   *  @example Keypress.register('shift d', { trackMsg: 'Shift-D is pressed' }, function () { console.log('Shift-D is pressed!') })\n   *  @example Keypress.register('esc', hide)\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {object} [options]\n   *    Options that fine tune the behavior of the keypress. If you are unhappy\n   *    with a default setting, they can be overridden here. Note that it is\n   *    possible for overrides to conflict with other parameters, for instance,\n   *    if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   *    Don't do this. This is confusing and I won't guarantee preserving how\n   *    this conflict is addressed.\n   *  @param {(boolean|string)} [options.shiftKey=false]\n   *    If `true`, the `Shift` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `shift` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Shift` is\n   *    pressed.\n   *  @param {(boolean|string)} [options.metaKey=false]\n   *    If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   *    should be pressed in a key combination. This is automatically set to\n   *    `true` if `meta`, `control`, or `command` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Command` or\n   *    `Control` is pressed.\n   *  @param {(boolean|string)} [options.altKey=false]\n   *    If `true`, the `Alt` key should be pressed in a key combination. This\n   *    is automatically set to `true` if `alt` is specified in the `commands`\n   *    parameter. The boolean test is strict. The string 'optional' can be\n   *    passed so that the key will fire regardless of whether `Alt` is pressed.\n   *  @param {(boolean)} [options.preventDefault=true]\n   *    If `true`, `event.preventDefault()` should be called to prevent the\n   *    key's default behavior.\n   *  @param {(boolean)} [options.stopPropagation=false]\n   *    If `true`, `event.stopPropagation()` should be called to prevent other\n   *    key handlers from triggering. Defaults to `false`, but as a special\n   *    case, this is automatically set to `true` if the command is `esc`.\n   *  @param {(boolean)} [options.requireFocusOnBody=true]\n   *    If `true`, the key handler is not triggered if the browser has focused\n   *    on a specific element, like an input field.  Defaults to `true`, but as\n   *    a special case, this is automatically set to `false` if the command is\n   *    `esc`.\n   *  @param {(string)} [options.trackMsg=null]\n   *    If a string is provided, the action is logged in event tracking when\n   *    triggered.\n   *  @param {(number)} [options.trackValue=null]\n   *    If set, and an event is logged, this fills in the `value` property of a\n   *    tracked event in Google Analytics.\n   *  @param {(boolean)} [options.trackOnce=true]\n   *    If `true`, and an event is logged, further identical actions will not\n   *    be logged.\n   *  @param {(function)} [options.onKeyPress]\n   *    It is possible to set the callback function to execute on key press on\n   *    the `options` object instead of in the `callback` parameter.\n   *  @param {(function)} [options.condition]\n   *    If additional conditions are required before executing a callback\n   *    function after a key is pressed, this function is evaluated. It must\n   *    return a `true` or truthy value for the callback to execute.\n   *  @param {function} [callback]\n   *    Function to execute when key is pressed. Technically, this is optional\n   *    (and you might prefer to set it on `options` instead). If there is no\n   *    callback function the keypress simply does nothing.\n   */\n  function register (commands, options, callback) {\n    // Defaults\n    // For shiftKey, metaKey, and altKey, specifies what it should\n    // match on the event object reported by the browser. For instance,\n    // if event.metaKey is false, it means the command must be executed\n    // only if the meta key (ctrl or command depending on the OS) is not\n    // pressed. (Note that ctrlKey will be internally mapped to behave\n    // the same as metaKey here.) The distinction is strict, pass the\n    // value 'optional' to make the system ignore whether a key is pressed.\n    var defaults = {\n      shiftKey: false,\n      metaKey: false,\n      altKey: false,\n      onKeypress: noop,\n      condition: returnTrue,\n      preventDefault: true,\n      stopPropagation: false,\n      requireFocusOnBody: true,\n      trackMsg: null,\n      trackValue: null,\n      trackOnce: true\n    }\n\n    // Check if the second argument is the options object or the callback function\n    if (typeof arguments[1] === 'object') {\n      options = arguments[1]\n    } else if (typeof arguments[1] === 'function') {\n      // The second argument is the callback function\n      // You cannot pass two callback functions\n      options = {}\n      callback = arguments[1]\n    }\n\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n\n        // Get default settings\n        for (var key in defaults) {\n          if (typeof command[i][key] === 'undefined') {\n            command[i][key] = defaults[key]\n          }\n        }\n\n        // Special case for 'ESC' key; it defaults to global (window) focus\n        if (parseInt(keyCode, 10) === KEYS['esc']) {\n          command[i].requireFocusOnBody = false\n          command[i].stopPropagation = true\n        }\n\n        // Attach callback function to execute\n        if (typeof callback === 'function') {\n          command[i].onKeypress = callback\n        }\n\n        // If options are specified, replace defaults\n        // This basically allows other code to override settings via the\n        // options object - it's dumb, but there's no protection against it,\n        // and who knows, could be useful in edge cases\n        for (var k in options) {\n          if (typeof command[i][k] !== options[k]) {\n            command[i][k] = options[k]\n          }\n        }\n\n        // Add processed commands to module's inputs holder\n        if (typeof inputs[keyCode] === 'undefined') {\n          inputs[keyCode] = []\n        }\n        inputs[keyCode].push(command[i])\n      }\n    }\n  }\n\n  /**\n   *  Deregisters a key command listener, given matching `commands` and\n   *  `callback` parameters.\n   *\n   *  @public\n   *  @example Keypress.deregister('shift d') // Deregisters all triggers for `shift d`\n   *  @example Keypress.deregister('esc', hide) // Deregisters triggers matching callback function `hide` and key `esc`\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  @param {function} [callback]\n   *    Callback function to execute when key is pressed. This is if you want\n   *    to only remove key handlers that match the same callback. If you do not\n   *    provide a callback, all handlers that match `commands` are removed.\n   *  @todo Because of how function equality works, not all functions passed\n   *    in this way result in a true test of equality.\n   */\n  function deregister (commands, callback) {\n    var commandObj = _processCommands(commands)\n\n    // Process each command input\n    for (var keyCode in commandObj) {\n      var command = commandObj[keyCode]\n\n      for (var i = 0; i < command.length; i++) {\n        var items = inputs[keyCode]\n        var x = items.length\n\n        // A reverse while loop quickly removes all duplicates that matches\n        while (x--) {\n          var item = items[x]\n          var matchingCallback = false\n\n          if (item.onKeypress === callback) {\n            matchingCallback = true\n          } else if (typeof callback === 'undefined') {\n            matchingCallback = true\n          }\n\n          // Check for equality for command + function\n          if ((matchingCallback === true) &&\n              (item.shiftKey === command[i].shiftKey || item.shiftKey === 'optional') &&\n              (item.altKey === command[i].altKey || item.altKey === 'optional') &&\n              (item.metaKey === command[i].metaKey || item.metaKey === 'optional')) {\n            // If matches, remove it from the command list.\n            inputs[keyCode].splice(x, 1)\n          }\n        }\n      }\n    }\n  }\n\n\n  /**\n   *  Processes commands\n   *\n   *  @private\n   *  @param {(string|string[])} commands\n   *    Human readable key or key combination to listen for, in the form of \"a\"\n   *    or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   *    same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`\n   *  //@returns object\n   */\n  function _processCommands (commands) {\n    // If a string, force to one-element array, otherwise expect an array of strings\n    if (typeof commands === 'string') {\n      commands = new Array(commands)\n    }\n\n    var commandsObj = {}\n\n    // Process each command input\n    for (var i = 0; i < commands.length; i++) {\n      // Normalize command\n      //  - adjust to lower case\n      //  - replace command/cmd/control/ctrl to meta (this does not remove dupes)\n      var command = commands[i].toLowerCase().replace(/(command|cmd|control|ctrl)/g, 'meta').split(' ')\n      var settings = {\n        shiftKey: false,\n        altKey: false,\n        metaKey: false\n      }\n\n      // Check for existence of modifier keys\n      // Modifier keys are removed from input array\n      var isShift = command.indexOf('shift')\n      if (isShift > -1) {\n        settings.shiftKey = true\n        command.splice(isShift, 1)\n      }\n\n      var isAlt = command.indexOf('alt')\n      if (isAlt > -1) {\n        settings.altKey = true\n        command.splice(isAlt, 1)\n      }\n\n      var isMeta = command.indexOf('meta')\n      if (isMeta > -1) {\n        settings.metaKey = true\n        command.splice(isMeta, 1)\n      }\n\n      // First remaining item in the input array is the key code to test for.\n      // Does not support multi-keys, so rest of input (if provided) is ignored.\n      var keyCode = KEYS[command[0]]\n\n      // Keycodes might be a single number or an array\n      if (keyCode) {\n        var keys = []\n        // If keyCode is a number, convert to single-element array\n        // Can't do a shortcut version of these with numbers :-/\n        if (typeof keyCode === 'number') {\n          keys.push(keyCode)\n        } else if (Array.isArray(keyCode)) {\n          keys = keyCode\n        }\n\n        for (var j = 0; j < keys.length; j++) {\n          settings.keyCode = keys[j]\n          if (typeof commandsObj[keys[j]] === 'undefined') {\n            commandsObj[keys[j]] = []\n          }\n\n          commandsObj[keys[j]].push(settings)\n        }\n      }\n    }\n\n    return commandsObj\n  }\n\n  function _onGlobalKeyDown (event) {\n    var input\n\n    // Find the right command object\n    var commandsForKeyCode = inputs[event.keyCode]\n    if (!commandsForKeyCode || commandsForKeyCode.length === 0) return\n\n    // Check if the right meta keys are down\n    for (var i = 0; i < commandsForKeyCode.length; i++) {\n      var item = commandsForKeyCode[i]\n      if ((item.shiftKey === event.shiftKey || item.shiftKey === 'optional') &&\n          (item.altKey === event.altKey || item.altKey === 'optional') &&\n          (item.metaKey === event.metaKey || item.metaKey === 'optional')) {\n        input = item\n      }\n    }\n\n    // Execute input's callback, if found\n    if (input) {\n      _execute(input, event)\n    }\n  }\n\n  /**\n   *  Executes an input's callback function\n   *\n   *  @private\n   *  @param {object} input - The input object to execute\n   *  @param {Event} [event] - The browser's `Event` object created when `keydown` is fired\n   */\n  function _execute (input, event) {\n    // Check if condition is satisfied\n    if (!input.condition()) return\n\n    // Check if focus is on the correct place\n    if (input.requireFocusOnBody === true && _isFocusOnBody() === false) return\n\n    if (event && input.preventDefault) {\n      event.preventDefault()\n    }\n    if (event && input.stopPropagation) {\n      event.stopPropagation()\n    }\n    if (input.trackMsg) {\n      EventTracking.track(TRACK_CATEGORY_INTERACTION, input.trackMsg, TRACK_LABEL_KEYBOARD, input.trackValue, input.trackOnce)\n    }\n\n    // Execute callback\n    input.onKeypress()\n  }\n\n  // Utility function\n  function _isFocusOnBody () {\n    return document.activeElement === document.body\n  }\n\n  return {\n    init: init,\n    register: register,\n    deregister: deregister,\n    inputs: inputs,\n    _proc: _processCommands\n  }\n\n}"
    },
    "access": "public",
    "examples": [
      "Keypress.register(<span class=\"hljs-string\">'shift d'</span>, { trackMsg: <span class=\"hljs-string\">'Shift-D is pressed'</span> }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Shift-D is pressed!'</span>) })",
      "Keypress.register(<span class=\"hljs-string\">'esc'</span>, hide)"
    ],
    "params": [
      {
        "title": "param",
        "description": "Human readable key or key combination to listen for, in the form of \"a\"\n   or \"shift a\" or \"control alt a\". If multiple keys should perform the\n   same action, pass in an array of strings, e.g. `['a', 'b', 'meta d']`",
        "lineNumber": 6,
        "type": {
          "type": "UnionType",
          "elements": [
            {
              "type": "NameExpression",
              "name": "string"
            },
            {
              "type": "TypeApplication",
              "expression": {
                "type": "NameExpression",
                "name": "Array"
              },
              "applications": [
                {
                  "type": "NameExpression",
                  "name": "string"
                }
              ]
            }
          ]
        },
        "name": "commands"
      },
      {
        "title": "param",
        "description": "Options that fine tune the behavior of the keypress. If you are unhappy\n   with a default setting, they can be overridden here. Note that it is\n   possible for overrides to conflict with other parameters, for instance,\n   if you set `commands` to \"shift p\" but `options.shiftKey` to `false`.\n   Don't do this. This is confusing and I won't guarantee preserving how\n   this conflict is addressed.",
        "lineNumber": 10,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "object"
          }
        },
        "name": "options",
        "properties": [
          {
            "title": "param",
            "description": "If `true`, the `Shift` key should be pressed in a key combination. This\n   is automatically set to `true` if `shift` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Shift` is\n   pressed.",
            "lineNumber": 17,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.shiftKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the \"meta\" key (`Command` or `Control`, depending on the OS)\n   should be pressed in a key combination. This is automatically set to\n   `true` if `meta`, `control`, or `command` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Command` or\n   `Control` is pressed.",
            "lineNumber": 23,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.metaKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the `Alt` key should be pressed in a key combination. This\n   is automatically set to `true` if `alt` is specified in the `commands`\n   parameter. The boolean test is strict. The string 'optional' can be\n   passed so that the key will fire regardless of whether `Alt` is pressed.",
            "lineNumber": 30,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  },
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.altKey",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, `event.preventDefault()` should be called to prevent the\n   key's default behavior.",
            "lineNumber": 35,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.preventDefault",
            "default": "true"
          },
          {
            "title": "param",
            "description": "If `true`, `event.stopPropagation()` should be called to prevent other\n   key handlers from triggering. Defaults to `false`, but as a special\n   case, this is automatically set to `true` if the command is `esc`.",
            "lineNumber": 38,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.stopPropagation",
            "default": "false"
          },
          {
            "title": "param",
            "description": "If `true`, the key handler is not triggered if the browser has focused\n   on a specific element, like an input field.  Defaults to `true`, but as\n   a special case, this is automatically set to `false` if the command is\n   `esc`.",
            "lineNumber": 42,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.requireFocusOnBody",
            "default": "true"
          },
          {
            "title": "param",
            "description": "If a string is provided, the action is logged in event tracking when\n   triggered.",
            "lineNumber": 47,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "string"
                  }
                ]
              }
            },
            "name": "options.trackMsg",
            "default": "null"
          },
          {
            "title": "param",
            "description": "If set, and an event is logged, this fills in the `value` property of a\n   tracked event in Google Analytics.",
            "lineNumber": 50,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "number"
                  }
                ]
              }
            },
            "name": "options.trackValue",
            "default": "null"
          },
          {
            "title": "param",
            "description": "If `true`, and an event is logged, further identical actions will not\n   be logged.",
            "lineNumber": 53,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "boolean"
                  }
                ]
              }
            },
            "name": "options.trackOnce",
            "default": "true"
          },
          {
            "title": "param",
            "description": "It is possible to set the callback function to execute on key press on\n   the `options` object instead of in the `callback` parameter.",
            "lineNumber": 56,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "function"
                  }
                ]
              }
            },
            "name": "options.onKeyPress"
          },
          {
            "title": "param",
            "description": "If additional conditions are required before executing a callback\n   function after a key is pressed, this function is evaluated. It must\n   return a `true` or truthy value for the callback to execute.",
            "lineNumber": 59,
            "type": {
              "type": "OptionalType",
              "expression": {
                "type": "UnionType",
                "elements": [
                  {
                    "type": "NameExpression",
                    "name": "function"
                  }
                ]
              }
            },
            "name": "options.condition"
          }
        ]
      },
      {
        "title": "param",
        "description": "Function to execute when key is pressed. Technically, this is optional\n   (and you might prefer to set it on `options` instead). If there is no\n   callback function the keypress simply does nothing.",
        "lineNumber": 63,
        "type": {
          "type": "OptionalType",
          "expression": {
            "type": "NameExpression",
            "name": "function"
          }
        },
        "name": "callback"
      }
    ],
    "name": "register",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "register"
    ]
  }
]